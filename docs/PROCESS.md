I built a dark and light mode toggle for a simple React time tracking app. It lets the user switch themes with a button in the header, updates the entire UI instantly, and remembers the preference using localStorage so the selected theme persists after refresh.
The micro iteration actually felt really good, because breaking it into tiny steps made it easy to test and catch issues early instead of debugging everything at the end, I felt like I had control and I found it more predictable. The only frustrating part was when something small didn’t behave as expected, for example at one point, the theme was not affecting the full page because the attribute was scoped wrong, but since the steps were small, fixing it was quick. Also, the self review caught real issues. For example, it found that if localStorage contained an invalid value like “banana,” the UI label would say dark mode was active even though the CSS wasn’t. It also caught a wrong CSS variable name (--surface-card instead of --bg-surface) that would have caused inconsistent styling, and those are the kinds of subtle bugs that are easy to miss during manual testing.
The AI tended to consistently catch edge cases and small logic inconsistencies, especially around state validation and variable mismatches. It was good at spotting things that wouldn’t crash the app but would create silent inconsistencies. I didn’t notice it missing anything major in this case, though I still had to visually confirm behavior in the browser.
I didn’t really like the browser-based experience. It felt slower and more limited compared to working directly in VS Code or the terminal. I prefer using the built in VS Code features or a CLI tool because they feel faster, more integrated into my workflow, and give me more control over files, commits, and branches. The browser version felt a bit disconnected from the actual development environment. I would still use micro-iteration and self-review as a workflow, but I’d do it inside VS Code or through the terminal. It makes sense for UI features, refactors, and state-related logic where small mistakes can cascade and visual consistency matters. I’d skip it for quick prototypes, throwaway scripts, or very small isolated changes where adding structure would just slow me down.
